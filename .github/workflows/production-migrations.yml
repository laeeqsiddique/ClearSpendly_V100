name: Production - Database Migrations

on:
  push:
    branches: [ main ]
    paths:
      - 'supabase/migrations/**'
  workflow_dispatch:
    inputs:
      skip_backup:
        description: 'Skip database backup (not recommended for production)'
        required: false
        default: false
        type: boolean
      force_migration:
        description: 'Force migration even if validation warnings exist'
        required: false
        default: false
        type: boolean

env:
  SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
  SUPABASE_PROJECT_ID: ${{ secrets.SUPABASE_PRODUCTION_PROJECT_ID }}
  SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_PRODUCTION_DB_PASSWORD }}

jobs:
  pre-migration-checks:
    name: Pre-Migration Security & Safety Checks
    runs-on: ubuntu-latest
    outputs:
      migration-count: ${{ steps.count.outputs.count }}
      risk-level: ${{ steps.risk.outputs.level }}
      requires-approval: ${{ steps.approval.outputs.required }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Supabase CLI
        run: |
          curl -o supabase.deb https://github.com/supabase/cli/releases/latest/download/supabase_linux_amd64.deb
          sudo dpkg -i supabase.deb

      - name: Count and analyze migrations
        id: count
        run: |
          count=$(find supabase/migrations -name "*.sql" -not -name "*rollback*" | wc -l)
          echo "count=$count" >> $GITHUB_OUTPUT
          echo "Found $count migration files"
          
          # Analyze recent migrations (last 5 commits)
          recent_migrations=$(git diff --name-only HEAD~5 HEAD -- supabase/migrations/ | wc -l)
          echo "recent_migrations=$recent_migrations" >> $GITHUB_OUTPUT
          echo "Recent migrations in last 5 commits: $recent_migrations"

      - name: Analyze migration risk level
        id: risk
        run: |
          echo "Analyzing migration risk level..."
          risk_level="LOW"
          risk_factors=()
          
          # Check for high-risk operations
          for file in supabase/migrations/*.sql; do
            if [[ -f "$file" ]] && [[ ! "$file" =~ rollback ]]; then
              content=$(cat "$file")
              
              # Check for destructive operations
              if echo "$content" | grep -iq "DROP TABLE\|DROP COLUMN\|ALTER TABLE.*DROP\|DELETE FROM\|TRUNCATE"; then
                risk_level="HIGH"
                risk_factors+=("Destructive operations detected in $(basename "$file")")
              fi
              
              # Check for large data operations
              if echo "$content" | grep -iq "CREATE INDEX\|ALTER TABLE.*ADD COLUMN.*NOT NULL\|UPDATE.*SET"; then
                if [[ "$risk_level" != "HIGH" ]]; then
                  risk_level="MEDIUM"
                fi
                risk_factors+=("Potentially blocking operations in $(basename "$file")")
              fi
              
              # Check for RLS policy changes
              if echo "$content" | grep -iq "CREATE POLICY\|ALTER POLICY\|DROP POLICY"; then
                if [[ "$risk_level" == "LOW" ]]; then
                  risk_level="MEDIUM"
                fi
                risk_factors+=("RLS policy changes in $(basename "$file")")
              fi
            fi
          done
          
          echo "level=$risk_level" >> $GITHUB_OUTPUT
          echo "Risk Level: $risk_level"
          
          if [ ${#risk_factors[@]} -gt 0 ]; then
            echo "Risk factors identified:"
            printf '%s\n' "${risk_factors[@]}"
            echo "risk_factors<<EOF" >> $GITHUB_OUTPUT
            printf '%s\n' "${risk_factors[@]}" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Determine approval requirement
        id: approval
        run: |
          risk_level="${{ steps.risk.outputs.level }}"
          migration_count="${{ steps.count.outputs.count }}"
          force_migration="${{ github.event.inputs.force_migration }}"
          
          # Require approval for high-risk migrations or large migration sets
          if [[ "$risk_level" == "HIGH" ]] || [[ "$migration_count" -gt 10 ]] && [[ "$force_migration" != "true" ]]; then
            echo "required=true" >> $GITHUB_OUTPUT
            echo "Manual approval required due to risk level: $risk_level"
          else
            echo "required=false" >> $GITHUB_OUTPUT
            echo "No manual approval required"
          fi

      - name: Validate against staging
        run: |
          echo "Validating migrations against staging environment..."
          
          # This would ideally connect to staging to verify schema compatibility
          # For now, we'll run local validation
          npm run deploy:check-migrations

      - name: Security scan of migration files
        run: |
          echo "Scanning migration files for security issues..."
          
          security_issues=()
          
          for file in supabase/migrations/*.sql; do
            if [[ -f "$file" ]] && [[ ! "$file" =~ rollback ]]; then
              content=$(cat "$file")
              
              # Check for potential security issues
              if echo "$content" | grep -iq "CREATE USER\|GRANT ALL\|SUPERUSER\|CREATE ROLE"; then
                security_issues+=("Privileged user operations in $(basename "$file")")
              fi
              
              if echo "$content" | grep -iq "pg_read_server_files\|pg_write_server_files\|pg_execute_server_program"; then
                security_issues+=("Server file system access in $(basename "$file")")
              fi
            fi
          done
          
          if [ ${#security_issues[@]} -gt 0 ]; then
            echo "‚ö†Ô∏è Security concerns identified:"
            printf '%s\n' "${security_issues[@]}"
            echo "Please review these security-sensitive operations carefully."
          else
            echo "‚úÖ No security issues detected in migration files"
          fi

  approval-gate:
    name: Manual Approval for High-Risk Migrations
    runs-on: ubuntu-latest
    needs: pre-migration-checks
    if: needs.pre-migration-checks.outputs.requires-approval == 'true'
    environment: 
      name: production-approval
      url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
    
    steps:
      - name: Request manual approval
        run: |
          echo "üö® HIGH-RISK MIGRATION DETECTED"
          echo "Risk Level: ${{ needs.pre-migration-checks.outputs.risk-level }}"
          echo "Migration Count: ${{ needs.pre-migration-checks.outputs.migration-count }}"
          echo ""
          echo "This migration requires manual approval before proceeding to production."
          echo "Please review the migration files and approve this deployment."

  backup-production:
    name: Backup Production Database
    runs-on: ubuntu-latest
    needs: [pre-migration-checks, approval-gate]
    if: always() && (needs.approval-gate.result == 'success' || needs.pre-migration-checks.outputs.requires-approval == 'false') && github.event.inputs.skip_backup != 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Supabase CLI
        run: |
          curl -o supabase.deb https://github.com/supabase/cli/releases/latest/download/supabase_linux_amd64.deb
          sudo dpkg -i supabase.deb

      - name: Create comprehensive database backup
        run: |
          echo "Creating comprehensive backup of production database..."
          timestamp=$(date +%Y%m%d_%H%M%S)
          
          # Create full database dump
          backup_file="production_backup_${timestamp}.sql"
          schema_file="production_schema_${timestamp}.sql"
          
          # Full backup
          supabase db dump \
            --project-id $SUPABASE_PROJECT_ID \
            --password $SUPABASE_DB_PASSWORD \
            --file $backup_file
          
          # Schema-only backup for quick reference
          supabase db dump \
            --project-id $SUPABASE_PROJECT_ID \
            --password $SUPABASE_DB_PASSWORD \
            --schema-only \
            --file $schema_file
          
          echo "backup_file=$backup_file" >> $GITHUB_ENV
          echo "schema_file=$schema_file" >> $GITHUB_ENV
          echo "‚úÖ Backup created: $backup_file"
          
          # Verify backup integrity
          if [ -f "$backup_file" ] && [ -s "$backup_file" ]; then
            echo "‚úÖ Backup file verification passed"
          else
            echo "‚ùå Backup file verification failed"
            exit 1
          fi

      - name: Upload backups to artifacts
        uses: actions/upload-artifact@v4
        with:
          name: production-db-backup-${{ github.run_id }}
          path: |
            ${{ env.backup_file }}
            ${{ env.schema_file }}
          retention-days: 90

      - name: Store backup metadata
        run: |
          echo "Creating backup metadata..."
          cat > backup_metadata.json << EOF
          {
            "timestamp": "$(date -Iseconds)",
            "run_id": "${{ github.run_id }}",
            "commit_sha": "${{ github.sha }}",
            "backup_file": "${{ env.backup_file }}",
            "schema_file": "${{ env.schema_file }}",
            "migration_count": "${{ needs.pre-migration-checks.outputs.migration-count }}",
            "risk_level": "${{ needs.pre-migration-checks.outputs.risk-level }}",
            "branch": "${{ github.ref_name }}"
          }
          EOF
          
          echo "Backup metadata created"

      - name: Upload backup metadata
        uses: actions/upload-artifact@v4
        with:
          name: backup-metadata-${{ github.run_id }}
          path: backup_metadata.json
          retention-days: 90

  run-production-migrations:
    name: Execute Production Migrations
    runs-on: ubuntu-latest
    needs: [pre-migration-checks, approval-gate, backup-production]
    if: always() && (needs.approval-gate.result == 'success' || needs.pre-migration-checks.outputs.requires-approval == 'false') && (needs.backup-production.result == 'success' || github.event.inputs.skip_backup == 'true')
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Supabase CLI
        run: |
          curl -o supabase.deb https://github.com/supabase/cli/releases/latest/download/supabase_linux_amd64.deb
          sudo dpkg -i supabase.deb

      - name: Link to Supabase project
        run: |
          supabase link \
            --project-ref $SUPABASE_PROJECT_ID \
            --password $SUPABASE_DB_PASSWORD

      - name: Pre-migration health check
        run: |
          echo "Running pre-migration health checks..."
          
          # Check database connectivity and basic health
          npm run health:db
          
          # Check current migration status
          echo "Current migration status:"
          supabase migration list --project-id $SUPABASE_PROJECT_ID
          
          echo "‚úÖ Pre-migration health checks passed"

      - name: Execute migrations with monitoring
        id: migrate
        run: |
          echo "üöÄ Starting production database migrations..."
          echo "Risk Level: ${{ needs.pre-migration-checks.outputs.risk-level }}"
          echo "Migration Count: ${{ needs.pre-migration-checks.outputs.migration-count }}"
          
          # Set up comprehensive error handling
          set -euo pipefail
          
          # Start migration with logging
          start_time=$(date +%s)
          echo "Migration started at: $(date -Iseconds)"
          
          # Run migrations with verbose output and error capture
          if ! supabase db push --include-all 2>&1 | tee migration_output.log; then
            echo "‚ùå Migration failed!"
            echo "MIGRATION_STATUS=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          end_time=$(date +%s)
          duration=$((end_time - start_time))
          
          echo "‚úÖ Migrations completed successfully"
          echo "Migration duration: ${duration} seconds"
          
          # Count applied migrations
          applied_count=$(grep -c "Applied migration" migration_output.log || echo "0")
          echo "applied_count=$applied_count" >> $GITHUB_OUTPUT
          echo "migration_duration=$duration" >> $GITHUB_OUTPUT
          echo "MIGRATION_STATUS=success" >> $GITHUB_OUTPUT

      - name: Post-migration verification
        run: |
          echo "Running post-migration verification..."
          
          # Wait a moment for changes to propagate
          sleep 5
          
          # Run comprehensive health checks
          echo "1. Database connectivity check..."
          npm run health:db
          
          echo "2. Tenant isolation check..."
          npm run health:tenant
          
          echo "3. API health check..."
          if command -v curl &> /dev/null; then
            # These would be your actual API endpoints
            echo "API health checks would run here"
          fi
          
          echo "‚úÖ Post-migration verification completed successfully"

      - name: Test critical functionality
        run: |
          echo "Testing critical multi-tenant functionality..."
          
          # Run any critical functionality tests
          # This could include testing RLS policies, data integrity, etc.
          
          if [ -f "supabase/migrations/test_rls_policies.sql" ]; then
            echo "Running RLS policy tests..."
            supabase db remote --project-id $SUPABASE_PROJECT_ID < supabase/migrations/test_rls_policies.sql
            echo "‚úÖ RLS policy tests passed"
          fi
          
          echo "‚úÖ Critical functionality tests completed"

      - name: Update production deployment status
        run: |
          echo "üéâ PRODUCTION MIGRATION COMPLETED SUCCESSFULLY"
          echo "Applied ${{ steps.migrate.outputs.applied_count }} migrations"
          echo "Duration: ${{ steps.migrate.outputs.migration_duration }} seconds"
          echo "Timestamp: $(date -Iseconds)"
          
          # Log deployment success
          echo "PRODUCTION_MIGRATION_STATUS=success" >> $GITHUB_ENV
          echo "PRODUCTION_MIGRATION_TIME=$(date -Iseconds)" >> $GITHUB_ENV

      - name: Post success notification
        uses: actions/github-script@v7
        with:
          script: |
            const appliedCount = '${{ steps.migrate.outputs.applied_count }}';
            const duration = '${{ steps.migrate.outputs.migration_duration }}';
            const migrationTime = process.env.PRODUCTION_MIGRATION_TIME;
            const riskLevel = '${{ needs.pre-migration-checks.outputs.risk-level }}';
            
            const comment = `## üéâ Production Migration Completed Successfully
            
            ‚úÖ **Status**: Success
            üìä **Applied Migrations**: ${appliedCount}
            ‚è±Ô∏è **Duration**: ${duration} seconds
            üïê **Completed**: ${migrationTime}
            üîí **Risk Level**: ${riskLevel}
            üåç **Environment**: Production
            
            ### Migration Summary
            - Database backup completed ‚úÖ
            - Pre-migration health checks passed ‚úÖ
            - Migrations applied successfully ‚úÖ
            - Post-migration verification passed ‚úÖ
            - Critical functionality tested ‚úÖ
            
            ### Backup Information
            - Backup artifacts stored for 90 days
            - Schema backup available for quick reference
            - Rollback capability maintained
            
            **üöÄ Your production environment is now updated and fully operational!**
            `;
            
            // Create a new issue for deployment record
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Production Deployment Complete - ${migrationTime}`,
              body: comment,
              labels: ['deployment', 'production', 'migration']
            });

  rollback-on-failure:
    name: Emergency Rollback Procedure
    runs-on: ubuntu-latest
    needs: [pre-migration-checks, backup-production, run-production-migrations]
    if: failure() && needs.backup-production.result == 'success'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Supabase CLI
        run: |
          curl -o supabase.deb https://github.com/supabase/cli/releases/latest/download/supabase_linux_amd64.deb
          sudo dpkg -i supabase.deb

      - name: Download backup files
        uses: actions/download-artifact@v4
        with:
          name: production-db-backup-${{ github.run_id }}

      - name: Download backup metadata
        uses: actions/download-artifact@v4
        with:
          name: backup-metadata-${{ github.run_id }}

      - name: Execute emergency rollback
        run: |
          echo "üö® EXECUTING EMERGENCY ROLLBACK PROCEDURE"
          echo "This is a critical operation to restore production database"
          
          # Load backup metadata
          backup_info=$(cat backup_metadata.json)
          backup_file=$(echo "$backup_info" | jq -r '.backup_file')
          
          if [ -f "$backup_file" ]; then
            echo "Initiating rollback from backup: $backup_file"
            echo "Backup timestamp: $(echo "$backup_info" | jq -r '.timestamp')"
            
            # Execute rollback
            npm run deploy:rollback
            
            echo "‚úÖ Emergency rollback completed"
          else
            echo "‚ùå Backup file not found: $backup_file"
            echo "Available files:"
            ls -la
            exit 1
          fi

      - name: Verify rollback integrity
        run: |
          echo "Verifying database integrity after rollback..."
          
          # Run health checks
          npm run health:db
          npm run health:tenant
          
          echo "‚úÖ Rollback verification completed"

      - name: Create incident report
        uses: actions/github-script@v7
        with:
          script: |
            const backupInfo = JSON.parse(require('fs').readFileSync('backup_metadata.json', 'utf8'));
            
            const incidentReport = `## üö® PRODUCTION MIGRATION FAILURE - EMERGENCY ROLLBACK EXECUTED
            
            ### Incident Details
            - **Time**: ${new Date().toISOString()}
            - **Run ID**: ${{ github.run_id }}
            - **Commit**: ${{ github.sha }}
            - **Branch**: ${{ github.ref_name }}
            
            ### Rollback Details
            - **Backup File**: ${backupInfo.backup_file}
            - **Backup Timestamp**: ${backupInfo.timestamp}
            - **Migration Count**: ${backupInfo.migration_count}
            - **Risk Level**: ${backupInfo.risk_level}
            
            ### Actions Taken
            1. ‚úÖ Emergency rollback procedure executed
            2. ‚úÖ Database restored from pre-migration backup
            3. ‚úÖ Integrity verification completed
            4. üîî Development team notified
            
            ### Next Steps
            1. **IMMEDIATE**: Verify production functionality
            2. **URGENT**: Investigate migration failure root cause
            3. **REQUIRED**: Fix migration issues before retry
            4. **RECOMMENDED**: Additional testing in staging environment
            
            ### Failure Analysis Required
            Please review the migration logs and identify the root cause before attempting another deployment.
            
            **‚ö†Ô∏è Production environment has been restored to previous stable state.**
            `;
            
            // Create high-priority incident issue
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üö® PRODUCTION INCIDENT: Migration Failure & Rollback - ${new Date().toISOString()}`,
              body: incidentReport,
              labels: ['incident', 'production', 'rollback', 'high-priority'],
              assignees: [] // Add your team members here
            });

      - name: Emergency notification
        run: |
          echo "üö® CRITICAL: Production migration failed and rollback was executed"
          echo "üìß Team notification sent via GitHub issue"
          echo "üîç Please investigate the failure immediately"
          echo "‚ö†Ô∏è Do not attempt another deployment until root cause is identified"